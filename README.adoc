= re-state
:source-highlighter: coderay
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning
:endif::[]

image:https://img.shields.io/clojars/v/maximgb/re-state.svg[link=https://clojars.org/maximgb/re-state]
image:https://img.shields.io/badge/License-MIT-yellow.svg[link=https://raw.githubusercontent.com/MaximGB/re-restate/master/LICENSE]

Re-frame supplimentary library which routes dispatched events via statecharts implementing final state machines

== TL;DR

Re-state routes re-frame events via statechart interpreter, currently backed by https://xstate.js.org[XState] library,
thus allowing more fine grained event handling. A re-frame component might use a statechart interpreter to dispatch to and
handle events related only to the component. The library also implements facilities to isolate component state within re-frame
application database, thus making it possible to write real independent standalone components.

[NOTE]
====
Real life example can be found here: https://github.com/MaximGB/TetrisRF
====

== Instalation

[source, clojure]
----
{:deps {org.clojure/clojure {:mvn/version "1.10.0"} ;; <1>
        org.clojure/clojurescript {:mvn/version "1.10.520"} ;; <2>
        reagent/reagent {:mvn/version "0.8.1"} ;; <3>
        re-frame/re-frame {:mvn/version "0.10.6"} ;; <4>
        maximgb.re-state {:mvn/version "0.4.0-SNAPSHOT"}}} ;; <5>
----
<1>
<2>
<3>
<4>
<5> - Use up-to-date versions for your project here

== Usage

There're three required steps involved in creating a re-frame component which uses library boosted event handling and component isolation:

- Create a state machine (or statechart) definition which describes your component behaviour in statecharts terms
- Create an intrpreter (or a service) which will controll the behaviour of a particular component according to state machine definition
- Send events to your component controlling interpreter using `(interpreter-send!)` function.


=== Minimal example

In this example we create a very simple component which displays it's current state and a button allowing to cycle states.
The machine controlling the component behaviour, is very simple, it just cycles through three available states: `:one`, `:two`, `:three`,
with no other side effects.

[NOTE]
====
Basic example live demo is https://maximgb.github.io/re-state/examples/basic/[here].
====


[source, clojure]
----
(ns maximgb.re-state.example.basic
  (:require [re-frame.core :as rf]
            [reagent.core :as reagent]
            [maximgb.re-state.core :as rs])) ;; <1>


(rs/def-machine basic-machine {:id      :basic-machine
                               :initial :one
                               :states {:one   {:on {:click :two}}
                                        :two   {:on {:click :three}}
                                        :three {:on {:click :one}}}}) ;; <2>


(defn state-cycler [] ;; <3>
  (let [controller (rs/interpreter-start! (rs/interpreter! basic-machine)) ;; <4>
        state-sub (rs/isubscribe-state controller)] ;; <5>
    (fn []
      [:div
       "Current state is: "
       [:div {:style {:display :inline-block
                      :width "5em"}}
        @state-sub]
       [:button
        {:on-click #(rs/interpreter-send! controller :click)} ;; <6>
        "Next state"]])))


(defn -main []
  (reagent/render [:div
                   [:div "State cycler component, press \"Next state\" button to cycle states."]
                   [state-cycler]]
                  (.getElementById js/document "app"))) ;; <7>


(.addEventListener js/window "load" -main)
----
<1> Require library core namespace, which contains public API
<2> Define state machine: initial state, state transition rules
<3> Define form 2 reagent/re-frame component
<4> Create and start the controller (or interpreter, or service) interpreting machine defined
<5> Subscribe to this particular controller state value
<6> Send `:click` event to the controller upon button widget click
<7> Mount the example

[TIP]
====
Read more on machine difinition in https://xstate.js.org/docs[XState documentation]
====

== Statecharts DSL

[TIP]
====
To read more about statecharts please visit https://statecharts.github.io/ or find and read original David Harel
"Statecharts: A Visual Formalism for Complex Systems" paper.
====

=== Machine definition

A machine is defined with `(def-machine machine-name machine-config)` macro:

[source, clojure]
----
(def-machine my-machine ;; <1>
             {:id :my-machine ;; <2>
              :initial :ready ;; <3>
              :states {:ready {}} ;; <4>
----
<1> Machine name, it's used to define guards, actions and create machine behaviour executing interpreter.
<2> Machine id, optional, but might help to decypher error messages
<3> Initial state machine interpreter will start executing the machine behaviour from.
<4> Machine states definition, here I define only one `:ready` final state, since it's the state machine starts from.

=== States, events, guards and state transition actions

Machine states are defined in machine config under `:states` key. `:states` value is a map, where keys are state names
and values are state definitions. A finite state machine can be in only one of a finite number of states at any given time.
A state definition describes what actions to execute when machine enters the state (`:entry` key), what actions to execute
when machine exits the state (`:exit` key), and what transitions are possible for the given state (`:on` key).

A set of transitons for the state is defined under state definition `:on` key, the key value might be either map or a vector,
it describes what events are valid for the state, what are destination states for every event *(or to be more precise
for every event and guard condition)* and what actions to execute upon transition.

==== State transition actions

When machine transits from one state to another it might execute a set of actions, which being re-frame handlers might affect
re-frame application database, request co-effects and issue effects. Actions might be defined in-line in machine config as functions
to execute, or they can be designated via action ids. If action is designated in machine config via an id, then action implementation
should be defined using one of the following macros:

- `(def-action-db)` - similar to re-frame's `(reg-event-db)`
- `(def-action-fx)` - similar to re-frame's `(reg-event-fx)`
- `(def-action-ctx)` - similar to re-frame's `(reg-event-ctx)`

or their app db *_isolated_* counterparts:

- `(def-action-idb)`
- `(def-action-ifx)`
- `(def-action-ictx)`

.Action definition example:
[source, clojure]
----
(def-action-db
 my-machine ;; <1>
 :my-db-action ;; <2>
 [:my-co-effect-to-inject] ;; <3>
 (fn [db] ;; <4>
   (assoc db :key :value)))
----
<1> Machine name the action is defined for
<2> Machine unique action id
<3> *Optional* list of co-effects to inject into re-frame's co-effects map.
<4> Action handler

Transition actions a declared using `:actions` key of transition definition.

.The action might be used by machine like this:
[source, clojure]
----
(def-machine my-machine
             {:id :my-machine
              :initial :ready
              :states {:ready {:on {:run {:target :running
                                          :actions :my-db-action}}} ;; <1>
                       :running {}}})
----
<1> Action is referenced by id, it will be executed when machine transits from `:ready` to `:running` state has recieved `:run` event.
    Both single action id (or in-line function) and vector with mix of action ids / inline functions are valid.

[NOTE]
====
A simple traffic light example implemented using only states and strict state transition actins live demo
is https://maximgb.github.io/re-state/examples/actions/[here].
====

==== State entry / exit actions

When machine enters to or exits from a state it might execute entry and exit actions. To declare what actions to execute one should use
`:entry`, `:exit` keys of a state definition.

.State entry / exit actions designation
[source, clojure]
----
(def-machine my-machine
             {:id :my-machine
              :initial :ready
              :states {:ready {:entry :in-ready ;; <1>
                               :exit  :out-ready ;; <2>
                               :on {:run :running}} ;; <3>
                       :running {}}})
----
<1> An action or a vector of actions to execute upon state entry
<2> An action or a vector of actions to execute upon state exit
<3> If transition doesn't involve any actions specific for the transition initiating event then a shortened syntax can be used -
    just `:on {:event :target-state}`

////
[NOTE]
====
An updated traffic light example which uses entry / exit action live demo
is https://maximgb.github.io/re-state/examples/actions/[here], compare this the previous one.
====
////

==== Transition guards

TODO:

=== Parallel states

TODO:

=== Machine spawning service (co-effects/effects)

TODO:

=== Component isolation

TODO:

==== Isolated subscriptions

TODO:

==== Machine state subscription

TODO:
